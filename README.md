# Paradigms
Solutions for practical tasks from 2nd semester paradigms course
## Домашнее задание 15. Разбор выражений на Prolog

1. Доработайте правило `evaluate(Expression, Variables, Result)`, вычисляющее арифметические выражения.
     1. Пример вычисления выражения `2(-x)-3` для `x = 5`:
      ```Prolog
      evaluate(
          operation(op_subtract,
              operation(op_multiply,
                  const(2),
                  operation(op_negate, variable(x))
              ),
              const(3)
          ),
          [(x, 5)],
          -13
      )
      ```

      2. Поддерживаемые операции: сложение `(op_add, +)`, вычитание `(op_subtract, -)`, умножение `(op_multiply, *)`, деление `(op_divide, /)`, противоположное число `(op_negate, negate)`.
    
2. **Простой вариант**. Реализуйте правило `suffix_str(Expression, Atom)`, разбирающее/выводящее выражения, записанные в [польской записи](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, 
```Prolog
polish_str(
    operation(op_subtract,
        operation(op_multiply,
            const(2),
            operation(op_negate, variable(x))),
        const(3)
    ),
    '- * 2 negate x 3'
)
```

3. **Сложный вариант**. Реализуйте правило `infix_str(Expression, Atom)`, разбирающее/выводящее выражения, записанные в полноскобочной инфиксной форме. Например,
```Prolog
infix_str(
    operation(op_subtract,
        operation(op_multiply,
            const(2),
            operation(op_negate, variable(x))),
        const(3)
    ),
    '((2 * negate x) - 3)'
)
```

4. Правила должны быть реализованы с применением DC-грамматик.

### [Parser](paradigms/prolog-solutions/expression.pl)


## Домашнее задание 14. Деревья поиска на Prolog

1. Реализуйте ассоциативный массив `(map)` на основе деревьев поиска. Для решения можно реализовать любое дерево поиска логарифмической высоты.
2. **Простой вариант**. Разработайте правила:
    * `map_build(ListMap, TreeMap)`, строящее дерево из упорядоченного списка пар ключ-значение ( $\mathcal{O}(n)$ );
    * `map_get(TreeMap, Key, Value)`, проверяющее, что массив содержит заданную пару ключ-значение ( $\mathcal{O}(\log n)$ ).
3. **Сложный вариант**. Дополнительно разработайте правила:
    * `map_put(TreeMap, Key, Value, Result)`, добавляющее пару ключ-значение в массив, или заменяющее текущее значение для ключа ( $\mathcal{O}(\log n)$ );
    * `map_remove(TreeMap, Key, Result)`, удаляющее отображение для ключа ( $\mathcal{O}(\log n)$ );
    * `map_build(ListMap, TreeMap)`, строящее дерево из неупорядоченного списка пар ключ-значение ( $\mathcal{O}(n\cdot \log n)$ ).

### [TreeMap](paradigms/prolog-solutions/tree-map.pl)


## Домашнее задание 13. Простые числа на Prolog

1. Разработайте правила:
    * `prime(N)`, проверяющее, что $N$ – простое число.
    * `composite(N)`, проверяющее, что $N$ – составное число.
    * `prime_divisors(N, Divisors)`, проверяющее, что список `Divisors` содержит все простые делители числа $N$, упорядоченные по возрастанию. Если $N$ делится на простое число $P$ несколько раз, то `Divisors` должен содержать соответствующее число копий $P$.
2.  Варианты:
    * Простой: $N \leq 1000$
    * Сложный: $N\leq 10^5$
    * Бонусный: $N \leq 10^7$
3.  Вы можете рассчитывать, на то, что до первого запроса будет выполнено правило `init(MAX_N)`.

### [Primes](paradigms/prolog-solutions/primes.pl)


## Домашнее задание 12. Комбинаторные парсеры

1. **Простой вариант**. Реализуйте функцию `(parseObjectPostfix "expression")`, разбирающую выражения, записанные в суффиксной форме, и функцию `toStringPostfix`, возвращающую строковое представление выражения в этой форме. Например,
```Clojure
(toStringPostfix (parseObjectPostfix "( ( 2 x * ) 3 - )"))
```
должно возвращать `((2 x *) 3 -)`.

2. **Сложный вариант**. Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в инфиксной форме, и функцию `toStringInfix`, возвращающую строковое представление выражения в этой форме. Например,
```Clojure
(toStringInfix (parseObjectInfix "2 * x - 3"))
```
должно возвращать `((2 * x) - 3)`.

3. **Бонусный вариант**. Добавьте в библиотеку комбинаторов возможность обработки ошибок и продемонстрируйте ее использование в вашем парсере.
4. Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.


## Домашнее задание 11. Объектные выражения на Clojure

1. Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` и `Negate` для представления арифметических выражений.
  1. Пример описания выражения `2x-3`:
  ```Clojure
  (def expr
    (Subtract
      (Multiply
        (Constant 2)
        (Variable "x"))
      (Constant 3)))
  ```

  2. Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно 1.
  3. Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
  4. Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,

`(parseObject "(- (* 2 x) 3)")`

должно быть эквивалентно `expr`.

2. **Сложный вариант.**
    1. Конструкторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Парсер так же должен допускать произвольное число аргументов для +, -, *, /.
    2. Функция `(diff expression "variable")` должна возвращать выражение, представляющее производную исходного выражения по заданой перемененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Constant 2) (Constant 0))` и
 ```Clojure
(Subtract
  (Add
    (Multiply (Constant 0) (Variable "x"))
    (Multiply (Constant 2) (Constant 1)))
  (Constant 0))
```
так же будут считаться правильным ответом.

3. При выполнении задания можно использовать любой способ преставления объектов.
4. При выполнении задания можно использовать функции, для определения JS-like объектов, приведённые на лекции.

### [Expression-clojure](paradigms/clojure-solutions/expression.clj)


## Домашнее задание 10. Функциональные выражения на Clojure

1.  Разработайте конструкторы `constant`, `variable`, `add`, `subtract`, `vultiply` и `divide` для представления выражений с одной переменной.
  * Пример описания выражения `2x-3`:
  ```Clojure
        (def expr
          (subtract
            (multiply
              (constant 2)
              (variable "x"))
            (constant 3)))
  ```                    
        
  *  Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. Например, `(expr {"x" 2})` должно быть равно 1.
  *  Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.
  *  Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,
        
        `(parseObject "(- (\* 2 x) 3)")`
        
        должно быть эквивалентно `expr`.
  *  Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))` и 
  ```Clojure
        (Subtract
          (Add
            (Multiply (Const 0) (Variable "x"))
            (Multiply (Const 2) (Const 1)))
          (Const 0))
  ```                   
  так же будут считаться правильным ответом.
  
2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,
  
`(parseFunction "(- (* 2 x) 3)")`

должно быть эквивалентно expr.

3. **Сложный вариант**. Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для +, -, *, /.
4.  При выполнении задания следует обратить внимание на:
      * Выделение общего кода для операций.

### [Functional-clojure](paradigms/clojure-solutions/expression.clj)


## Домашнее задание 9. Линейная алгебра на Clojure

1. Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:
      * скаляры – числа
      * векторы – векторы чисел;
      * матрицы – векторы векторов чисел.
2. Функции над векторами:
      * `v+`/`v-`/`v*`/`vd` – покоординатное сложение/вычитание/умножение/деление;
      * `scalar`/`vect` – скалярное/векторное произведение;
      * `v*s`– умножение на скаляр.

3. Функции над матрицами:
      * `m+`/`m-`/`m*`/`md` – поэлементное сложение/вычитание/умножение/деление;
      * `m*s` – умножение на скаляр;
      * `m*v` – умножение на вектор;
      * `m*m` – матричное умножение;
      * `transpose` – транспонирование;
4. **Сложный вариант.**
      1. Ко всем функциям должны быть указаны контракты. Например, нельзя складывать вектора разной длины.
      2. Все функции должны поддерживать произвольное число аргументов. Например `(v+ [1 2] [3 4] [5 6])` должно быть равно `[9 12]`.
5. При выполнении задания следует обратить внимание на:
      * Применение функций высшего порядка.
      * Выделение общего кода для операций.

### [Linear](paradigms/clojure-solutions/linear.clj)


## Домашнее задание 8. Обработка ошибок на JavaScript

1. Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `«(- (* 2 x) 3)»`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.
2. Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
3. При выполнении задания следует обратить внимание на:
      * Применение инкапсуляции.
      * Выделение общего кода для операций.
      * Минимизацию необходимой памяти.
      * Обработку ошибок.

### [ExceptionsJS](paradigms/javascript-solutions/objectExpression.js)


## Домашнее задание 7. Объектные выражения на JavaScript

1. Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с тремя переменными: `x`, `y` и `z`.
  * Пример описания выражения `2x-3`: 
  ```Javascript
        let expr = new Subtract(
            new Multiply(
                new Const(2),
                new Variable("x")
            ),
            new Const(3)
        );

        println(expr.evaluate(5, 0, 0));
  ```

  * При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.
  * Метод toString() должен выдавать запись выражения в [обратной польской записи](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, `expr.toString()` должен выдавать `«2 x * 3 -»`.
2. Функция `parse` должна выдавать разобранное объектное выражение.
3. **Сложный вариант.**
Метод `diff("x")` должен возвращать выражение, представляющее производную исходного выражения по переменной `x`. Например, `expr.diff("x")` должен возвращать выражение, эквивалентное `new Const(2)` (выражения `new Subtract(new Const(2), new Const(0))` и
```Javascript
new Subtract(
    new Add(
        new Multiply(new Const(0), new Variable("x")),
        new Multiply(new Const(2), new Const(1))
    )
    new Const(0)
)
```
так же будут считаться правильным ответом).

4. **Бонусный вариант**. Требуется написать метод `simplify()`, производящий вычисления константных выражений. Например,

`parse("x x 2 - * 1 *").diff("x").simplify().toString()`

должно возвращать `«x x 2 - +»`.
5. При выполнении задания следует обратить внимание на:
      * Применение инкапсуляции.
      * Выделение общего кода для операций.
      * Минимизацию необходимой памяти.

### [ObjectJS](paradigms/javascript-solutions/objectExpression.js)


## Домашнее задание 6. Функциональные выражения на JavaScript

1. Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с тремя переменными: `x`, `y` и `z`.
2. Функции должны позволять производить вычисления вида:
```Javascript
let expr = subtract(
    multiply(
        cnst(2),
        variable("x")
    ),
    cnst(3)
);

println(expr(5, 0, 0));
```

При вычислении выражения вместо каждой переменной подставляется значение, переданное в качестве соответствующего параметра функции `expr`. Таким образом, результатом вычисления приведенного примера должно быть число 7.

3. Тестовая программа должна вычислять выражение `$x^2$−2x+1`, для `x` от 0 до 10.
4. **Сложный вариант**. Требуется дополнительно написать функцию parse, осуществляющую разбор выражений, записанных в [обратной польской записи](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D1%81%D0%BA%D0%B0%D1%8F_%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D1%8C). Например, результатом

  `parse("x x 2 - * x * 1 +")(5, 0, 0)`

  должно быть число 76

5. При выполнении задания следует обратить внимание на:
      * Применение функций высшего порядка.
      * Выделение общего кода для операций. 

### [FunctionalJS](paradigms/javascript-solutions/functionalExpression.js)


## Домашнее задание 5. Вычисление в различных типах

Добавьте в программу разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.
1. Создайте класс `expression.generic.GenericTabulator`, реализующий интерфейс `expression.generic.Tabulator`:
```Java
public interface Tabulator {
        Object[][][] tabulate(
            String mode, String expression, 
            int x1, int x2, int y1, int y2, int z1, int z2
        ) throws Exception;
    }
```
  * Аргументы
      * mode — режим работы
      
        **Режим $\quad\quad$	Тип**

        i  $\quad\quad\quad\quad\quad$ int с детекцией переполнений
      
        d $\quad\quad\quad\quad\quad$ double

        bi $\quad\quad\quad\quad\quad$ [BigInteger](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.html)
      
      * expression — вычисляемое выражение;
      * `x1, x2; y1, y2; z1, z2` — диапазоны изменения переменных (включительно).
           
  Возвращаемое значение — таблица значений функции, где `R[i][j][k]` соответствует `x = x1 + i`, `y = y1 + j`, `z = z1 + k`. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть `null`.
  
2. Доработайте интерфейс командной строки:
      * Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производится вычисления:
       
        **Опция	$\quad\quad$ Тип**
        
          -i  $\quad\quad\quad\quad$ int с детекцией переполнений
          
          -d $\quad\quad\quad\quad$ double
          
          -bi $\quad\quad\quad\quad$ [BigInteger](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.html)
          
      * Вторым аргументом командной строки программа должна принимать выражение для вычисления.
      * Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.
3. Реализация не должна содержать [непроверяемых преобразований типов](https://docs.oracle.com/javase/specs/jls/se17/html/jls-5.html#jls-5.1.9).
4. Реализация не должна использовать аннотацию [@SuppressWarnings](https://docs.oracle.com/javase/specs/jls/se17/html/jls-9.html#jls-9.6.4.5).
5. При выполнении задания следует обратить внимание на простоту добавления новых типов и операциий.

### [Generics](paradigms/java-solutions/expression/generic)


## Домашнее задание 4. Очереди

1. Определите интерфейс очереди Queue и опишите его контракт.
2. Реализуйте класс `LinkedQueue` — очередь на связном списке.
3. Выделите общие части классов `LinkedQueue` и `ArrayQueue` в базовый класс `AbstractQueue`.

_Это домашнее задание связано с предыдущим._

### [Queues](paradigms/java-solutions/queue)


## Домашнее задание 3. Очередь на массиве

1. Определите модель и найдите инвариант структуры данных [«очередь»](http://ru.wikipedia.org/wiki/%D0%9E%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)).
      * Определите функции, которые необходимы для реализации очереди.
      * Найдите их пред- и постусловия, при условии что очередь не содержит `null`.
2. Реализуйте классы, представляющие **циклическую** очередь на основе массива.
      * Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.
      * Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).
      * Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).
      * Должны быть реализованы следующие функции (процедуры) / методы:
          * `enqueue` – добавить элемент в очередь;
          * `element` – первый элемент в очереди;
          * `dequeue` – удалить и вернуть первый элемент в очереди;
          * `size` – текущий размер очереди;
          * `isEmpty` – является ли очередь пустой;
          * `clear` – удалить все элементы из очереди.
      * Модель, инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
      * Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
3. Напишите тесты к реализованным классам.

### [Queues](paradigms/java-solutions/queue)


## Домашнее задание 2. Бинарный поиск

1. Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
2. На вход подается целое число `x` и массив целых чисел `a`, отсортированный по невозрастанию. Требуется найти минимальное значение индекса `i`, при котором `a[i] <= x`.
3. Для `main`, функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
4. Интерфейс программы.
      * Имя основного класса — `search.BinarySearch`.
      * Первый аргумент командной строки — число `x`.
      * Последующие аргументы командной строки — элементы массива `a`.
5. Пример запуска: `java search.BinarySearch 3 5 4 3 2 1`. Ожидаемый результат: 2.

### [BinarySearch](paradigms/java-solutions/search/BinarySearch.java)

## Домашнее задание 1. Обработка ошибок
1. Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:
      * ошибки разбора выражений;
      * ошибки вычисления выражений.
2. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
```Java
  x       f
  0       0
  1       division by zero
  2       32000000
  3       121500000
  4       341333333
  5       overflow
  6       overflow
  7       overflow
  8       overflow
  9       overflow
  10      overflow
```
3. При выполнении задания следует обратить внимание на дизайн и обработку исключений.
4. Человеко-читаемые сообщения об ошибках должны выводиться на консоль.
5. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными).

### [Exceptions](paradigms/java-solutions/expression/exceptions)
